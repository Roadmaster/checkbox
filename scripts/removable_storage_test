#!/usr/bin/env python3

import dbus
import sys
import random
import os
import tempfile
import hashlib
import argparse
import subprocess
import threading
import time

from shutil import copy2

class ActionTimer():
    '''Class to implement a simple timer'''
    def __enter__(self):
        self.start = time.time()
        return self

    def __exit__(self, *args):
        self.stop = time.time()
        self.interval = self.stop - self.start

class DiskTest():
    ''' Class to contain various methods for testing USB disks '''
    def __init__(self):
        self.process = None
        self.cmd = None
        self.timeout = 3
        self.returnCode = None
        self.rem_disks = {}     # mounted before the script running
        self.rem_disks_nm = {}  # not mounted before the script running

    def generate_test_data(self, size):
        '''Generate a random data file of a given size'''
        min = 100
        max = 1000000
        self.tfile = tempfile.NamedTemporaryFile(delete=False)
        while os.path.getsize(self.tfile.name) < size:
            self.tfile.write(str(random.randint(min, max)).encode('UTF-8'))

    def md5_hash_file(self, path):
        try:
            fh = open(path, 'r')
        except IOError:
            print("ERROR: unable to open file %s" % path, file=sys.stderr)
            return 1
        md5 = hashlib.md5()
        try:
            while True:
                data = fh.read(8192)
                if not data:
                    break
                md5.update(data.encode('utf-8'))
        finally:
            fh.close()
        return md5.hexdigest()

    def copy_file(self, source, dest):
        try:
            copy2(source, dest)
        except IOError:
            print("ERROR: Unable to copy the file to %s" % dest,
                file=sys.stderr)
            return False
        else:
            return True

    def compare_hash(self, parent, child):
        if not parent == child:
            return False
        else:
            return True

    def clean_up(self, target):
        try:
            os.unlink(target)
        except:
            print("ERROR: Unable to remove tempfile %s" % target,
                file=sys.stderr)

    def get_disk_info(self, device):
        ''' Probes dbus to find any attached/mounted devices'''
        bus = dbus.SystemBus()
        ud_manager_obj = bus.get_object("org.freedesktop.UDisks",
                                        "/org/freedesktop/UDisks")
        ud_manager = dbus.Interface(ud_manager_obj, 'org.freedesktop.UDisks')
        self.rem_disks = {}
        self.rem_disks_nm = {}
        for dev in ud_manager.EnumerateDevices():
            device_obj = bus.get_object("org.freedesktop.UDisks", dev)
            device_props = dbus.Interface(device_obj, dbus.PROPERTIES_IFACE)
            udisks = 'org.freedesktop.UDisks.Device'
            if not device_props.Get(udisks, "DeviceIsDrive"):
                if device_props.Get(udisks,
                                    "DriveConnectionInterface") in device:
                    dev_file = str(device_props.Get(udisks, "DeviceFile"))

                    if len(device_props.Get(udisks, "DeviceMountPaths")) > 0:
                        devPath = str(device_props.Get(udisks,
                                                       "DeviceMountPaths")[0])
                        self.rem_disks[dev_file] = devPath
                    else:
                        self.rem_disks_nm[dev_file] = None

    def mount(self):
        passed_mount = {}

        for key, dummy in self.rem_disks_nm.items():
            file = tempfile.mkdtemp(dir='/tmp')

            result = False
            try:
                result = self.make_thread(self._mount(key, file))
            except:
                pass

            # remove those devices fail at mounting
            if result:
                passed_mount[key] = file
            else:
                print("ERROR: can't mount %s" % (key), file=sys.stderr)

        if len(self.rem_disks_nm) == len(passed_mount):
            self.rem_disks_nm = passed_mount
            return 0
        else:
            count = len(self.rem_disks_nm) - len(passed_mount)
            self.rem_disks_nm = passed_mount
            return count

    def _mount(self, dev_file, tmp_dir):
        cmd = ['/bin/mount', dev_file, tmp_dir]
        self.process = subprocess.Popen(cmd)
        self.process.communicate()

    def umount(self):
        errors = 0

        for disk in self.rem_disks_nm:
            result = False
            try:
                result = self.make_thread(self._umount(disk))
            except:
                errors += 1
                pass

            if not result:
                print("ERROR: can't umount %s on %s"
                       % (disk, self.rem_disks_nm[disk]), file=sys.stderr)

        return errors

    def _umount(self, dir):
        # '-l': lazy umount, dealing problem of unable to umount the device.
        cmd = ['/bin/umount', '-l', dir]
        self.process = subprocess.Popen(cmd)
        self.process.communicate()

    def clean_tmp_dir(self):
        for disk in self.rem_disks_nm:
            if not os.path.ismount(self.rem_disks_nm[disk]):
                os.rmdir(self.rem_disks_nm[disk])

    def make_thread(self, target):
        thread = threading.Thread(target=target)
        thread.start()
        thread.join(self.timeout)

        if thread.is_alive():
            self.process.terminate()
            thread.join()

        result = getattr(self.process, 'returncode', 1)

        if result == 0:
            return True
        else:
            return False


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('device',
                        choices=['usb', 'firewire', 'sdio', 'scsi', 'ata_serial_esata'],
                        nargs='+',
                        help=("The type of removable media "
                              "(usb, firewire, sdio, scsi or ata_serial_esata) to test."))
    parser.add_argument('-l', '--list',
                        action='store_true',
                        default=False,
                        help="List the removable devices and mounting status")
    parser.add_argument('-c', '--count',
                        action='store',
                        default='1',
                        type=int,
                        help='The number of times to run the test')
    parser.add_argument('-s', '--size',
                        action='store',
                        type=int,
                        default=1048576,
                        help=("The size of the test data file to use "
                              "in Bytes. Default is %(default)s"))
    parser.add_argument('-n', '--skip-not-mount',
                        action='store_true',
                        default=False,
                        help=("skip the removable devices "
                              "which haven't been mounted before the test."))

    args = parser.parse_args()

    test = DiskTest()

    test.get_disk_info(args.device)

    errors = 0
    # If we do have removable drives attached and mounted
    if len(test.rem_disks) > 0 or len(test.rem_disks_nm) > 0:
        if args.list:  # Simply output a list of drives detected
            print('-' * 20)
            print("Removable devices currently mounted:")
            if len(test.rem_disks) > 0:
                for disk, mount_point in test.rem_disks.items():
                    print("%s : %s" % (disk, mount_point))
            else:
                print("None")

            print("Removable devices currently not mounted:")
            if len(test.rem_disks_nm) > 0:
                for disk, dummy in test.rem_disks_nm.items():
                    print(disk)
            else:
                print("None")

            print('-' * 20)

            return 0

        else:  # Create a file, copy to USB and compare hashes
            if args.skip_not_mount:
                disks_all = test.rem_disks
            else:
                # mount those haven't be mounted yet.
                errors_mount = test.mount()

                if errors_mount > 0:
                    print("There're total %d device(s) failed at mounting."
                           % errors_mount)
                    errors += errors_mount

                disks_all = dict(list(test.rem_disks.items())
                                 + list(test.rem_disks_nm.items()))

            if len(disks_all) > 0:
                print("Found the following mounted %s partitions:"
                       % args.device)

                for disk, mount_point in disks_all.items():
                    print("    %s : %s" % (disk, mount_point))

                print('-' * 20)

                write_times = []
                try:
                    for iteration in range(args.count):
                        test.generate_test_data(args.size)
                        parent_hash = test.md5_hash_file(test.tfile.name)
                        for disk, mount_point in disks_all.items():
                            with ActionTimer() as timer:
                                if not test.copy_file(test.tfile.name, mount_point):
                                    print("ERROR: Failed to copy %s to %s" %
                                        (test.tfile.name, mount_point), file=sys.stderr)
                                    errors += 1
                                    continue
                            print("[Iteration %s] Copy took %0.3f secs." %
                                    (iteration, timer.interval))
                            write_times.append(timer.interval)

                            target = os.path.join(mount_point,
                                          os.path.basename(test.tfile.name))
                            child_hash = test.md5_hash_file(target)
                            if not test.compare_hash(parent_hash, child_hash):
                                print("ERROR: [Iteration %s] Parent and Child"
                                        "copy hashes mismatch on %s!" %
                                        (iteration,mount_point), file=sys.stderr)
                                print("\tParent hash: %s" % parent_hash,
                                        file=sys.stderr)
                                print("\tChild hash: %s" % child_hash,
                                        file=sys.stderr)
                                errors += 1
                            test.clean_up(target)
                        test.clean_up(test.tfile.name)
                finally:
                    if (len(test.rem_disks_nm) > 0):
                        if test.umount() != 0:
                            errors += 1
                        test.clean_tmp_dir()

                if errors > 0:
                    print("ERROR: Completed %s test iterations, "
                           "but there were errors" % args.count, file=sys.stderr)
                    return 1
                else:
                    print("Successfully completed %s %s file transfer "
                           "test iterations"
                           % (args.count, args.device))
                    total_write_time = sum(write_times)
                    avg_write_time = total_write_time / args.count
                    avg_write_speed = (args.size / avg_write_time) / 1024
                    print("Total time writing data: %0.4f" % total_write_time)
                    print("Average time per write: %0.4f" % avg_write_time)
                    print("Average write speed: %0.4f KB/s" %
                            avg_write_speed)
                    return 0
            else:
                print("ERROR: No device being mounted successfully for testing, "
                      "aborting", file=sys.stderr)
                return 1

    else:  # If we don't have removable drives attached and mounted
        print("ERROR: No removable drives were detected, aborting", file=sys.stderr)
        return 1

if __name__ == '__main__':
    sys.exit(main())
