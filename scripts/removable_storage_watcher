#!/usr/bin/env python3

import argparse
import dbus
import logging
import re
import sys

from dbus.exceptions import DBusException
from gi.repository import GObject

from checkbox.dbus import connect_to_system_bus
from checkbox.dbus.udisks2 import UDisks2Model, UDisks2Observer


def is_udisks2_supported(system_bus):
    """
    Check if udisks2 is available on the system bus.

    ..note::
        Calling this _may_ trigger activation of the UDisks2 daemon but it
        should only happen on systems where it is already expected to run all
        the time.
    """
    observer = UDisks2Observer()
    try:
        logging.debug("Trying to connect to UDisks2...")
        observer.connect_to_bus(system_bus)
    except DBusException as exc:
        if exc.get_dbus_name() == "org.freedesktop.DBus.Error.ServiceUnknown":
            logging.debug("No UDisks2 on the system bus")
            return False
        else:
            raise
    else:
        logging.debug("Got UDisks2 connection")
        return True


class UDisks1StorageDeviceListener:

    def __init__(self, system_bus, loop, action, devices, minimum_speed,
                 memorycard):
        self._action = action
        self._devices = devices
        self._minimum_speed = minimum_speed
        self._memorycard = memorycard
        self._bus = system_bus
        self._loop = loop
        self._error = False
        self._change_cache = []

    def check(self, timeout):
        udisks = 'org.freedesktop.UDisks'
        if self._action == 'insert':
            signal = 'DeviceAdded'
            logging.debug("Adding signal listener for %s.%s", udisks, signal)
            self._bus.add_signal_receiver(self.add_detected,
                                          signal_name=signal,
                                          dbus_interface=udisks)
        elif self._action == 'remove':
            signal = 'DeviceRemoved'
            logging.debug("Adding signal listener for %s.%s", udisks, signal)
            self._bus.add_signal_receiver(self.remove_detected,
                                          signal_name=signal,
                                          dbus_interface=udisks)

        self._starting_devices = self.get_existing_devices()
        logging.debug("Starting with the following devices: %r",
                      self._starting_devices)

        def timeout_callback():
            print("%s seconds have expired "
                  "waiting for the device to be inserted." % timeout)
            self._error = True
            self._loop.quit()

        logging.debug("Adding timeout listener, timeout=%r", timeout)
        GObject.timeout_add_seconds(timeout, timeout_callback)
        logging.debug("Starting event loop...")
        self._loop.run()

        return self._error

    def verify_device_change(self, changed_devices, message=""):
        logging.debug("Verifying device change: %s", changed_devices)
        # Filter the applicable bus types, as provided on the command line
        # (values of self._devices can be 'usb', 'firewire', etc)
        desired_bus_devices = [
            device
            for device in changed_devices
            if device[1] in self._devices]
        logging.debug("Desired bus devices: %s", desired_bus_devices)
        pattern = re.compile('SD|MMC|CF|MS|SM|xD|Card|Generic')
        for dev in desired_bus_devices:
            if self._memorycard:
                if dev[1] != 'sdio' and not pattern.search(dev[3], re.I):
                    logging.debug("The device does not seem to be a memory"
                                  " card (dev[1]: %r, dev[3]: %r), skipping",
                                 dev[1], dev[3])
                    return
                print(message % {'bus': 'memory card', 'file': dev[0]})
            else:
                if pattern.search(dev[3], re.I):
                    logging.debug("The device seems to be a memory"
                                  " card %s (dev[3]: %r), skipping",
                                  pattern, dev[3])
                    return
                print(message % {'bus': dev[1], 'file': dev[0]})
            if self._minimum_speed:
                if dev[2] >= self._minimum_speed:
                    print("with speed of %(speed)s bits/s "
                          "higher than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                else:
                    print("ERROR: speed of %(speed)s bits/s lower "
                          "than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                    self._error = True
            logging.debug("Device matches requirements, exiting event loop")
            self._loop.quit()

    def job_change_detected(self, devices, job_in_progress, job_id,
                            job_num_tasks, job_cur_task_id,
                            job_cur_task_percentage):
        logging.debug("UDisks1 reports a job change has been detected:"
                      " devices: %s, job_in_progress: %s, job_id: %s,"
                      " job_num_tasks: %s, job_cur_task_id: %s,"
                      " job_cur_task_percentage: %s",
                      devices, job_in_progress, job_id, job_num_tasks,
                      job_cur_task_id, job_cur_task_percentage)
        if job_id == "FilesystemMount":
            if devices in self._change_cache:
                logging.debug("Ignoring filesystem mount,"
                              " the device is present in change cache")
                return
            logging.debug("Adding devices to change cache: %r", devices)
            self._change_cache.append(devices)
            logging.debug("Starting devices were: %s", self._starting_devices)
            current_devices = self.get_existing_devices()
            logging.debug("Current devices are: %s", current_devices)
            inserted_devices = list(set(current_devices) -
                                    set(self._starting_devices))
            logging.debug("Computed inserted devices: %s", inserted_devices)
            if self._memorycard:
                message = "Expected memory card device %(file)s inserted"
            else:
                message = "Expected %(bus)s device %(file)s inserted"
            self.verify_device_change(inserted_devices,
                      message=message)

    def add_detected(self, added_path):
        logging.debug("UDisks1 reports device has been added: %s", added_path)
        logging.debug("Resetting change_cache to []")
        self._change_cache = []
        signal_name = 'DeviceJobChanged'
        dbus_interface = 'org.freedesktop.UDisks'
        logging.debug("Adding signal listener for %s.%s",
                      dbus_interface, signal_name)
        self._bus.add_signal_receiver(self.job_change_detected,
                                      signal_name=signal_name,
                                      dbus_interface=dbus_interface)

    def remove_detected(self, removed_path):
        logging.debug("UDisks1 reports device has been removed: %s",
                      removed_path)

        logging.debug("Starting devices were: %s", self._starting_devices)
        current_devices = self.get_existing_devices()
        logging.debug("Current devices are: %s", current_devices)
        removed_devices = list(set(self._starting_devices) -
                               set(current_devices))
        logging.debug("Computed removed devices: %s", removed_devices)
        self.verify_device_change(removed_devices,
                  message="Removable %(bus)s device %(file)s has been removed")

    def get_existing_devices(self):
        logging.debug("Getting existing devices from UDisks1")
        ud_manager_obj = self._bus.get_object("org.freedesktop.UDisks",
                                              "/org/freedesktop/UDisks")
        ud_manager = dbus.Interface(ud_manager_obj, 'org.freedesktop.UDisks')
        existing_devices = []
        for dev in ud_manager.EnumerateDevices():
            try:
                device_obj = self._bus.get_object("org.freedesktop.UDisks",
                                                  dev)
                device_props = dbus.Interface(device_obj,
                                              dbus.PROPERTIES_IFACE)
                udisks = 'org.freedesktop.UDisks.Device'
                _device_file = device_props.Get(udisks,
                                           "DeviceFile")
                _device = device_props.Get(udisks,
                                           "DriveConnectionInterface")
                _speed = device_props.Get(udisks,
                                                "DriveConnectionSpeed")
                _parent_model = ''

                if device_props.Get(udisks, "DeviceIsPartition"):
                    parent_obj = self._bus.get_object(
                        "org.freedesktop.UDisks",
                        device_props.Get(udisks, "PartitionSlave"))
                    parent_props = dbus.Interface(
                        parent_obj, dbus.PROPERTIES_IFACE)
                    _parent_model = parent_props.Get(udisks, "DriveModel")

                if not device_props.Get(udisks, "DeviceIsDrive"):
                    device = (
                        str(_device_file),
                        str(_device),
                        int(_speed),
                        str(_parent_model))
                    existing_devices.append(device)

            except dbus.DBusException:
                pass

        return existing_devices


class UDisks2StorageDeviceListener:
    """
    Implementation of the storage device listener concept for UDisks2 backend.
    Loosely modeled on the UDisks-based implementation above.
    """

    # Name of the DBus interface exposed UDisks2 for various drives
    UDISKS2_DRIVE_INTERFACE = "org.freedesktop.UDisks2.Drive"

    # Name of the DBus property provided by the "Drive" interface above
    UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS = "ConnectionBus"

    def __init__(self, system_bus, loop, action, devices, minimum_speed,
                 memorycard):
        # TODO: Document arguments
        # Requested action to detect
        if action not in ("insert", "remove"):
            raise ValueError("Unsupported action: {}".format(action))
        self._action = action
        # We'll use the UDisks2 "ConnectionBus" property on the "Drive"
        # interface to do primary filtering. According to the documentation it
        # may have the following values: usb, sdio, ieee1394. The 'devices'
        # argument uses somewhat different strings. In particular we need to
        # map 'ieee1394' to 'firewire'
        #
        # See: http://udisks.freedesktop.org/docs/latest/gdbus-org.freedesktop.UDisks2.Drive.html#gdbus-property-org-freedesktop-UDisks2-Drive.ConnectionBus
        #
        # TODO: Report old unsupported possibilities that are still offered by
        # the command-line interface. We also need samples to understand how
        # UDisks2 behaves in practice on various devices.
        self._desired_connection_buses = [
            device if device != 'firewire' else 'ieee1394'
            for device in devices]
        # Store DBus bus object as we need to pass it to UDisks2 observer
        self._bus = system_bus
        # Store main loop object
        self._loop = loop
        # Setup UDisks2Observer class to track changes published by UDisks2
        self._udisks2_observer = UDisks2Observer()
        # Register a callback for either device insertion or removal, depending
        # on the required test. IMPORTANT: those callbacks will be processed
        # before the internal callbacks registered by UDisks2Model. This is
        # essential as it will allow us to react before the model is updated.
        if self._action == "insert":
            self._udisks2_observer.on_interfaces_added.connect(
                self._on_interfaces_added)
        elif self._action == "remove":
            self._udisks2_observer.on_interfaces_removed.connect(
                self._on_interfaces_removed)
        # Setup UDisks2Model to know what the current state is. This is needed
        # when remove events are reported as they don't carry enough state for
        # the program to work correctly. Since UDisks2Model only applies the
        # changes _after_ processing the signals from UDisks2Observer we can
        # reliably check all of the properties of the removed object / device.
        self._udisks2_model = UDisks2Model(self._udisks2_observer)
        # Assume the test passes, this is changed when timeout expires or when
        # an incorrect device gets inserted.
        self._error = False

    def check(self, timeout):
        """
        Run the configured test and return the result

        The result is False if the test has failed.  The timeout, when
        non-zero, will make the test fail after the specified seconds have
        elapsed without conclusive result.
        """
        # Setup a timeout if requested
        if timeout > 0:
            GObject.timeout_add_seconds(timeout, self._on_timeout_expired)
        # Connect the observer to the bus. This will start giving us events
        # (actually when the loop starts later below)
        self._udisks2_observer.connect_to_bus(self._bus)
        # Start the loop and wait. The loop will exit either when:
        # 1) A proper device has been detected (either insertion or removal)
        # 2) A timeout (optional) has expired
        self._loop.run()
        # Return the outcome of the test
        return self._error

    def _on_timeout_expired(self):
        """
        Internal function called when the timer expires.

        Basically it's just here to tell the user the test failed or that the
        user was unable to alter the device during the allowed time.
        """
        print("You have failed to perform the required manipulation in time")
        # Fail the test when the timeout was reached
        self._error = True
        # Stop the loop now
        self._loop.quit()

    def _on_interfaces_added(self, object_path, interfaces_and_properties):
        """
        Internal function called when UDisks2 notices new objects
        """
        for interface, properties in interfaces_and_properties.items():
            # Check all added interfaces, look for the "Drive" interface only
            if interface != self.UDISKS2_DRIVE_INTERFACE:
                continue
            # Stop the test after seeing a "Drive" interface
            self._loop.quit()
            # Whenever a drive is plugged in but not on the bus that we
            # expected signal an error and quit looking for more.
            connection_bus = (
                properties.get(self.UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS))
            if connection_bus not in self._desired_connection_buses:
                self._error = True
                print("You have inserted a device on bus {!r},"
                      " expected: {!r}".format(connection_bus,
                                               self._desired_connection_buses))
            else:
                print("Expected device {path} "
                      "inserted on the {bus} bus".format(
                          path=object_path, bus=connection_bus))
            # TODO: check for memory cards precisely
            # TODO: minimum speed unsupported in UDisks2,
            # needs separate USB3 checks

    def _on_interfaces_removed(self, object_path, interfaces):
        """
        Internal function called when UDisks2 notices removed objects
        """
        for interface in interfaces:
            # Check all added interfaces, look for the "Drive" interface only
            if interface != self.UDISKS2_DRIVE_INTERFACE:
                continue
            # Stop the test after seeing a "Drive" interface
            self._loop.quit()
            # Whenever a drive is removed but not on the bus that we
            # expected signal an error and quit looking for more.
            try:
                interfaces_and_properties = (
                    self._udisks2_model.managed_objects[object_path])
                properties = (
                    interfaces_and_properties[self.UDISKS2_DRIVE_INTERFACE])
                connection_bus = (
                    properties[self.UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS])
            except KeyError:
                logging.error(
                    "Unable to locate connection bus used by %r", object_path)
                continue
            if connection_bus not in self._desired_connection_buses:
                self._error = True
                print("You have removed a device on bus {!r},"
                      " expected: {!r}".format(connection_bus,
                                               self._desired_connection_buses))
            else:
                print("Expected device {path} "
                      "removed from the {bus} bus".format(
                          path=object_path, bus=connection_bus))
            # TODO: check for memory cards precisely
            # TODO: minimum speed unsupported in UDisks2,
            # needs separate USB3 checks


def main():
    description = "Wait for the specified device to be inserted or removed."
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('action', choices=['insert', 'remove'])
    parser.add_argument('device', choices=['usb', 'sdio', 'firewire', 'scsi',
                                 'ata_serial_esata'], nargs="+")
    memorycard_help = ("Memory cards devices on bus other than sdio require "
                       "this parameter to identify them as such")
    parser.add_argument('--memorycard', action="store_true",
                        help=memorycard_help)
    parser.add_argument('--timeout', type=int, default=20)
    min_speed_help = ("Will only accept a device if its connection speed "
                      "attribute is higher than this value "
                      "(in bits/s)")
    parser.add_argument('--minimum_speed', '-m', help=min_speed_help,
                        type=int, default=0)
    parser.add_argument('--verbose', action='store_const', const=logging.INFO,
                        dest='logging_level', help="Enable verbose output")
    parser.add_argument('--debug', action='store_const', const=logging.DEBUG,
                        dest='logging_level', help="Enable debugging")
    parser.set_defaults(logging_level=logging.WARNING)
    args = parser.parse_args()

    # Configure logging as requested
    # XXX: This may be incorrect as logging.basicConfig() fails after any other
    # call to logging.log(). The proper solution is to setup a verbose logging
    # configuration and I didn't want to do it now.
    logging.basicConfig(
        level=args.logging_level,
        format='[%(asctime)s] %(levelname)s:%(name)s:%(message)s')

    # Connect to the system bus, we also get the event
    # loop as we need it to start listening for signals.
    system_bus, loop = connect_to_system_bus()

    # Check if system bus has the UDisks2 object
    if is_udisks2_supported(system_bus):
        # Construct the listener with all of the arguments provided on the
        # command line and the explicit system_bus, loop objects.
        logging.debug("Using UDisks2 interface")
        listener = UDisks2StorageDeviceListener(
            system_bus, loop,
            args.action, args.device, args.minimum_speed, args.memorycard)
    else:
        # Construct the listener with all of the arguments provided on the
        # command line and the explicit system_bus, loop objects.
        logging.debug("Using UDisks1 interface")
        listener = UDisks1StorageDeviceListener(
            system_bus, loop,
            args.action, args.device, args.minimum_speed, args.memorycard)
    # Run the actual listener and wait till it either times out of discovers
    # the appropriate media changes
    try:
        return listener.check(args.timeout)
    except KeyboardInterrupt:
        return 1

if __name__ == "__main__":
    sys.exit(main())
