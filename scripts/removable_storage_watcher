#!/usr/bin/env python3

import argparse
import dbus
import re
import sys

from gi.repository import GObject

from checkbox.dbus import connect_to_system_bus


class StorageDeviceListener:

    def __init__(self, system_bus, loop, action, devices, minimum_speed,
                 memorycard):
        self._action = action
        self._devices = devices
        self._minimum_speed = minimum_speed
        self._memorycard = memorycard
        self._bus = system_bus
        self._loop = loop
        self._error = False
        self._change_cache = []

    def check(self, timeout):
        udisks = 'org.freedesktop.UDisks'
        if self._action == 'insert':
            self._bus.add_signal_receiver(self.add_detected,
                                          signal_name='DeviceAdded',
                                          dbus_interface=udisks)
        elif self._action == 'remove':
            self._bus.add_signal_receiver(self.remove_detected,
                                          signal_name='DeviceRemoved',
                                          dbus_interface=udisks)

        self._starting_devices = self.get_existing_devices()

        def timeout_callback():
            print("%s seconds have expired "
                  "waiting for the device to be inserted." % timeout)
            self._error = True
            self._loop.quit()

        GObject.timeout_add_seconds(timeout, timeout_callback)
        self._loop.run()

        return self._error

    def verify_device_change(self, changed_devices, message=""):
        desired_bus_devices = [device for device in changed_devices
                              if device[1] in self._devices]
        pattern = re.compile('SD|MMC|CF|MS|SM|xD|Card|Generic')
        for dev in desired_bus_devices:
            if self._memorycard:
                if dev[1] != 'sdio' and not pattern.search(dev[3], re.I):
                    return
                print(message % {'bus': 'memory card', 'file': dev[0]})
            else:
                if pattern.search(dev[3], re.I):
                    return
                print(message % {'bus': dev[1], 'file': dev[0]})
            if self._minimum_speed:
                if dev[2] >= self._minimum_speed:
                    print("with speed of %(speed)s bits/s "
                          "higher than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                else:
                    print("ERROR: speed of %(speed)s bits/s lower "
                          "than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                    self._error = True
            self._loop.quit()

    def job_change_detected(self, devices, job_in_progress, job_id,
                            job_num_tasks, job_cur_task_id,
                            job_cur_task_percentage):
        if job_id == "FilesystemMount":
            if devices in self._change_cache:
                return
            self._change_cache.append(devices)
            inserted_devices = list(set(self.get_existing_devices()) -
                                    set(self._starting_devices))
            if self._memorycard:
                message = "Expected memory card device %(file)s inserted"
            else:
                message = "Expected %(bus)s device %(file)s inserted"
            self.verify_device_change(inserted_devices,
                      message=message)

    def add_detected(self, added_path):
        self._change_cache = []
        self._bus.add_signal_receiver(self.job_change_detected,
                                      signal_name='DeviceJobChanged',
                                      dbus_interface='org.freedesktop.UDisks')

    def remove_detected(self, removed_path):
        removed_devices = list(set(self._starting_devices) -
                               set(self.get_existing_devices()))
        self.verify_device_change(removed_devices,
                  message="Removable %(bus)s device %(file)s has been removed")

    def get_existing_devices(self):
        ud_manager_obj = self._bus.get_object("org.freedesktop.UDisks",
                                              "/org/freedesktop/UDisks")
        ud_manager = dbus.Interface(ud_manager_obj, 'org.freedesktop.UDisks')
        existing_devices = []
        for dev in ud_manager.EnumerateDevices():
            try:
                device_obj = self._bus.get_object("org.freedesktop.UDisks",
                                                  dev)
                device_props = dbus.Interface(device_obj,
                                              dbus.PROPERTIES_IFACE)
                udisks = 'org.freedesktop.UDisks.Device'
                _device_file = device_props.Get(udisks,
                                           "DeviceFile")
                _device = device_props.Get(udisks,
                                           "DriveConnectionInterface")
                _speed = device_props.Get(udisks,
                                                "DriveConnectionSpeed")
                _parent_model = ''

                if device_props.Get(udisks, "DeviceIsPartition"):
                    parent_obj = self._bus.get_object(
                        "org.freedesktop.UDisks",
                        device_props.Get(udisks, "PartitionSlave"))
                    parent_props = dbus.Interface(
                        parent_obj, dbus.PROPERTIES_IFACE)
                    _parent_model = parent_props.Get(udisks, "DriveModel")

                if not device_props.Get(udisks, "DeviceIsDrive"):
                    device = (
                        str(_device_file),
                        str(_device),
                        int(_speed),
                        str(_parent_model))
                    existing_devices.append(device)

            except dbus.DBusException:
                pass

        return existing_devices


def main():
    description = "Wait for the specified device to be inserted or removed."
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('action', choices=['insert', 'remove'])
    parser.add_argument('device',
                        choices=['usb', 'sdio', 'firewire',
                        'scsi', 'ata_serial_esata'],
                        nargs=argparse.REMAINDER)
    memorycard_help = ("Memory cards devices on bus other than sdio require "
                       "this parameter to identify them as such")
    parser.add_argument('--memorycard', action="store_true",
                        help=memorycard_help)
    parser.add_argument('--timeout', type=int, default=20)
    min_speed_help = ("Will only accept a device if its connection speed "
                      "attribute is higher than this value "
                      "(in bits/s)")
    parser.add_argument('--minimum_speed', '-m', help=min_speed_help,
                        type=int, default=0)
    args = parser.parse_args()

    # Connect to the system bus, we also get the event
    # loop as we need it to start listening for signals.
    system_bus, loop = connect_to_system_bus()

    # Construct the listener with all of the arguments provided on the command
    # line and the explicit system_bus, loop objects.
    listener = StorageDeviceListener(
        system_bus, loop,
        args.action, args.device, args.minimum_speed, args.memorycard)
    return(listener.check(args.timeout))

if __name__ == "__main__":
    sys.exit(main())
