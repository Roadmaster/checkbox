#!/usr/bin/env python3

import argparse
import collections
import dbus
import logging
import re
import sys

from dbus.exceptions import DBusException
from gi.repository import GObject

from checkbox.dbus import connect_to_system_bus
from checkbox.dbus.udisks2 import UDisks2Model, UDisks2Observer

# Delta record that encapsulates difference:
# delta_dir -- directon of the difference, either DELTA_DIR_PLUS or
#              DELTA_DIR_MINUS
# value -- the actual value being removed or added, either InterfaceDelta or
# PropertyDelta instance, see below
DeltaRecord = collections.namedtuple("DeltaRecord", "delta_dir value")

# Delta value for representing interface changes
InterfaceDelta = collections.namedtuple(
    "InterfaceDelta",
    "delta_type object_path iface_name")

# Delta value for representing property changes
PropertyDelta = collections.namedtuple(
    "PropertyDelta",
    "delta_type object_path iface_name prop_name prop_value")

# Tokens that encode additions and removals
DELTA_DIR_PLUS = '+'
DELTA_DIR_MINUS = '-'

# Tokens that encode interface and property deltas
DELTA_TYPE_IFACE = 'i'
DELTA_TYPE_PROP = 'p'


def is_udisks2_supported(system_bus):
    """
    Check if udisks2 is available on the system bus.

    ..note::
        Calling this _may_ trigger activation of the UDisks2 daemon but it
        should only happen on systems where it is already expected to run all
        the time.
    """
    observer = UDisks2Observer()
    try:
        logging.debug("Trying to connect to UDisks2...")
        observer.connect_to_bus(system_bus)
    except DBusException as exc:
        if exc.get_dbus_name() == "org.freedesktop.DBus.Error.ServiceUnknown":
            logging.debug("No UDisks2 on the system bus")
            return False
        else:
            raise
    else:
        logging.debug("Got UDisks2 connection")
        return True


def format_bytes(size):
    """
    Format size to be easily read by humans

    The result is disk-size compatible (using multiples of 10
    rather than 2) string like "4.5GB"
    """
    for index, prefix in enumerate(" KMGTPEZY", 0):
        factor = 10 ** (index * 3)
        if size // factor <= 1000:
            break
    return "{}{}B".format(size // factor, prefix.strip())


def is_memory_card(vendor, model, udisks2_media):
    """
    Check if the device seems to be a memory card

    This is rather fuzzy, sadly udev and udisks2 don't do a very good job and
    mostly don't specify the "media" property (it has a few useful values, such
    as flash_cf, flash_ms, flash_sm, flash_sd, flash_sdhc, flash_sdxc and
    flash_mmc but I have yet to see a device that reports such values)
    """
    # Treat any device that match model name to the following regular
    # expression as a memory card reader.
    if re.search('SD|MMC|CF|MS|SM|xD|Card', model, re.I):
        return True
    # Treat any device that contains the word 'Generic' in the vendor string as
    # a memory card reader.
    #
    # XXX: This seems odd but strangely enough seems to gets the job done. I
    # guess if I should start filing tons of bugs/patches on udev/udisks2 to
    # just have a few more rules and make this rule obsolete.
    if re.match('Generic', vendor, re.I):
        return True
    # Treat any udisks2_media that starts with 'flash' as a memory card
    if udisks2_media is not None and udisks2_media.startswith('flash'):
        return True
    return False


class UDisks1StorageDeviceListener:

    def __init__(self, system_bus, loop, action, devices, minimum_speed,
                 memorycard):
        self._action = action
        self._devices = devices
        self._minimum_speed = minimum_speed
        self._memorycard = memorycard
        self._bus = system_bus
        self._loop = loop
        self._error = False
        self._change_cache = []

    def check(self, timeout):
        udisks = 'org.freedesktop.UDisks'
        if self._action == 'insert':
            signal = 'DeviceAdded'
            logging.debug("Adding signal listener for %s.%s", udisks, signal)
            self._bus.add_signal_receiver(self.add_detected,
                                          signal_name=signal,
                                          dbus_interface=udisks)
        elif self._action == 'remove':
            signal = 'DeviceRemoved'
            logging.debug("Adding signal listener for %s.%s", udisks, signal)
            self._bus.add_signal_receiver(self.remove_detected,
                                          signal_name=signal,
                                          dbus_interface=udisks)

        self._starting_devices = self.get_existing_devices()
        logging.debug("Starting with the following devices: %r",
                      self._starting_devices)

        def timeout_callback():
            print("%s seconds have expired "
                  "waiting for the device to be inserted." % timeout)
            self._error = True
            self._loop.quit()

        logging.debug("Adding timeout listener, timeout=%r", timeout)
        GObject.timeout_add_seconds(timeout, timeout_callback)
        logging.debug("Starting event loop...")
        self._loop.run()

        return self._error

    def verify_device_change(self, changed_devices, message=""):
        logging.debug("Verifying device change: %s", changed_devices)
        # Filter the applicable bus types, as provided on the command line
        # (values of self._devices can be 'usb', 'firewire', etc)
        desired_bus_devices = [
            device
            for device in changed_devices
            if device[1] in self._devices]
        logging.debug("Desired bus devices: %s", desired_bus_devices)
        pattern = re.compile('SD|MMC|CF|MS|SM|xD|Card|Generic')
        for dev in desired_bus_devices:
            if self._memorycard:
                if dev[1] != 'sdio' and not pattern.search(dev[3], re.I):
                    logging.debug("The device does not seem to be a memory"
                                  " card (dev[1]: %r, dev[3]: %r), skipping",
                                 dev[1], dev[3])
                    return
                print(message % {'bus': 'memory card', 'file': dev[0]})
            else:
                if pattern.search(dev[3], re.I):
                    logging.debug("The device seems to be a memory"
                                  " card %s (dev[3]: %r), skipping",
                                  pattern, dev[3])
                    return
                print(message % {'bus': dev[1], 'file': dev[0]})
            if self._minimum_speed:
                if dev[2] >= self._minimum_speed:
                    print("with speed of %(speed)s bits/s "
                          "higher than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                else:
                    print("ERROR: speed of %(speed)s bits/s lower "
                          "than %(min_speed)s bits/s" %
                          {'speed': dev[2], 'min_speed': self._minimum_speed})
                    self._error = True
            logging.debug("Device matches requirements, exiting event loop")
            self._loop.quit()

    def job_change_detected(self, devices, job_in_progress, job_id,
                            job_num_tasks, job_cur_task_id,
                            job_cur_task_percentage):
        logging.debug("UDisks1 reports a job change has been detected:"
                      " devices: %s, job_in_progress: %s, job_id: %s,"
                      " job_num_tasks: %s, job_cur_task_id: %s,"
                      " job_cur_task_percentage: %s",
                      devices, job_in_progress, job_id, job_num_tasks,
                      job_cur_task_id, job_cur_task_percentage)
        if job_id == "FilesystemMount":
            if devices in self._change_cache:
                logging.debug("Ignoring filesystem mount,"
                              " the device is present in change cache")
                return
            logging.debug("Adding devices to change cache: %r", devices)
            self._change_cache.append(devices)
            logging.debug("Starting devices were: %s", self._starting_devices)
            current_devices = self.get_existing_devices()
            logging.debug("Current devices are: %s", current_devices)
            inserted_devices = list(set(current_devices) -
                                    set(self._starting_devices))
            logging.debug("Computed inserted devices: %s", inserted_devices)
            if self._memorycard:
                message = "Expected memory card device %(file)s inserted"
            else:
                message = "Expected %(bus)s device %(file)s inserted"
            self.verify_device_change(inserted_devices,
                      message=message)

    def add_detected(self, added_path):
        logging.debug("UDisks1 reports device has been added: %s", added_path)
        logging.debug("Resetting change_cache to []")
        self._change_cache = []
        signal_name = 'DeviceJobChanged'
        dbus_interface = 'org.freedesktop.UDisks'
        logging.debug("Adding signal listener for %s.%s",
                      dbus_interface, signal_name)
        self._bus.add_signal_receiver(self.job_change_detected,
                                      signal_name=signal_name,
                                      dbus_interface=dbus_interface)

    def remove_detected(self, removed_path):
        logging.debug("UDisks1 reports device has been removed: %s",
                      removed_path)

        logging.debug("Starting devices were: %s", self._starting_devices)
        current_devices = self.get_existing_devices()
        logging.debug("Current devices are: %s", current_devices)
        removed_devices = list(set(self._starting_devices) -
                               set(current_devices))
        logging.debug("Computed removed devices: %s", removed_devices)
        self.verify_device_change(removed_devices,
                  message="Removable %(bus)s device %(file)s has been removed")

    def get_existing_devices(self):
        logging.debug("Getting existing devices from UDisks1")
        ud_manager_obj = self._bus.get_object("org.freedesktop.UDisks",
                                              "/org/freedesktop/UDisks")
        ud_manager = dbus.Interface(ud_manager_obj, 'org.freedesktop.UDisks')
        existing_devices = []
        for dev in ud_manager.EnumerateDevices():
            try:
                device_obj = self._bus.get_object("org.freedesktop.UDisks",
                                                  dev)
                device_props = dbus.Interface(device_obj,
                                              dbus.PROPERTIES_IFACE)
                udisks = 'org.freedesktop.UDisks.Device'
                _device_file = device_props.Get(udisks,
                                           "DeviceFile")
                _device = device_props.Get(udisks,
                                           "DriveConnectionInterface")
                _speed = device_props.Get(udisks,
                                                "DriveConnectionSpeed")
                _parent_model = ''

                if device_props.Get(udisks, "DeviceIsPartition"):
                    parent_obj = self._bus.get_object(
                        "org.freedesktop.UDisks",
                        device_props.Get(udisks, "PartitionSlave"))
                    parent_props = dbus.Interface(
                        parent_obj, dbus.PROPERTIES_IFACE)
                    _parent_model = parent_props.Get(udisks, "DriveModel")

                if not device_props.Get(udisks, "DeviceIsDrive"):
                    device = (
                        str(_device_file),
                        str(_device),
                        int(_speed),
                        str(_parent_model))
                    existing_devices.append(device)

            except dbus.DBusException:
                pass

        return existing_devices


def udisks2_objects_delta(old, new):
    """
    Compute the delta between two snapshots of udisks2 objects

    The objects are encoded as {s:{s:{s:v}}} where the first dictionary maps
    from DBus object path to a dictionary that maps from interface name to a
    dictionary that finally maps from property name to property value.

    The result is a generator of DeltaRecord objects that encodes the changes:
        * the 'delta_dir' is either DELTA_DIR_PLUS or DELTA_DIR_MINUS
        * the 'value' is a tuple that differs for interfaces and properties.
          Interfaces use the format (DELTA_TYPE_IFACE, object_path, iface_name)
          while properties use the format (DELTA_TYPE_PROP, object_path,
          iface_name, prop_name, prop_value)

    Interfaces are never "changed", they are only added or removed. Properties
    can be changed and this is encoded as removal followed by an addition where
    both differ only by the 'delta_dir' and the last element of the 'value'
    tuple.
    """
    # Traverse all objects, old or new
    all_object_paths = set()
    all_object_paths |= old.keys()
    all_object_paths |= new.keys()
    for object_path in sorted(all_object_paths):
        old_object = old.get(object_path, {})
        new_object = new.get(object_path, {})
        # Traverse all interfaces of each object, old or new
        all_iface_names = set()
        all_iface_names |= old_object.keys()
        all_iface_names |= new_object.keys()
        for iface_name in sorted(all_iface_names):
            if iface_name not in old_object and iface_name in new_object:
                # Report each ADDED interface
                assert iface_name in new_object
                delta_value = InterfaceDelta(
                    DELTA_TYPE_IFACE, object_path, iface_name)
                yield DeltaRecord(DELTA_DIR_PLUS, delta_value)
                # Report all properties ADDED on that interface
                for prop_name, prop_value in new_object[iface_name].items():
                    delta_value = PropertyDelta(DELTA_TYPE_PROP, object_path,
                                                iface_name, prop_name,
                                                prop_value)
                    yield DeltaRecord(DELTA_DIR_PLUS, delta_value)
            elif iface_name not in new_object and iface_name in old_object:
                # Report each REMOVED interface
                assert iface_name in old_object
                delta_value = InterfaceDelta(
                    DELTA_TYPE_IFACE, object_path, iface_name)
                yield DeltaRecord(DELTA_DIR_MINUS, delta_value)
                # Report all properties REMOVED on that interface
                for prop_name, prop_value in old_object[iface_name].items():
                    delta_value = PropertyDelta(DELTA_TYPE_PROP, object_path,
                                                iface_name, prop_name,
                                                prop_value)
                    yield DeltaRecord(DELTA_DIR_MINUS, delta_value)
            else:
                # Analyze properties of each interface that existed both in old
                # and new object trees.
                assert iface_name in new_object
                assert iface_name in old_object
                old_props = old_object[iface_name]
                new_props = new_object[iface_name]
                all_prop_names = set()
                all_prop_names |= old_props.keys()
                all_prop_names |= new_props.keys()
                # Traverse all properties, old or new
                for prop_name in sorted(all_prop_names):
                    if prop_name not in old_props and prop_name in new_props:
                        # Report each ADDED property
                        delta_value = PropertyDelta(
                            DELTA_TYPE_PROP, object_path, iface_name,
                            prop_name, new_props[prop_name])
                        yield DeltaRecord(DELTA_DIR_PLUS, delta_value)
                    elif prop_name not in new_props and prop_name in old_props:
                        # Report each REMOVED property
                        delta_value = PropertyDelta(
                            DELTA_TYPE_PROP, object_path, iface_name,
                            prop_name, old_props[prop_name])
                        yield DeltaRecord(DELTA_DIR_MINUS, delta_value)
                    else:
                        old_value = old_props[prop_name]
                        new_value = new_props[prop_name]
                        if old_value != new_value:
                            # Report each changed property
                            yield DeltaRecord(DELTA_DIR_MINUS, PropertyDelta(
                                DELTA_TYPE_PROP, object_path, iface_name,
                                prop_name, old_value))
                            yield DeltaRecord(DELTA_DIR_PLUS, PropertyDelta(
                                DELTA_TYPE_PROP, object_path, iface_name,
                                prop_name, new_value))


class UDisks2StorageDeviceListener:
    """
    Implementation of the storage device listener concept for UDisks2 backend.
    Loosely modeled on the UDisks-based implementation above.
    """

    # Name of the DBus interface exposed UDisks2 for various drives
    UDISKS2_DRIVE_INTERFACE = "org.freedesktop.UDisks2.Drive"

    # Name of the DBus property provided by the "Drive" interface above
    UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS = "ConnectionBus"

    def __init__(self, system_bus, loop, action, devices, minimum_speed,
                 memorycard):
        # TODO: Document arguments
        # Requested action to detect
        if action not in ("insert", "remove"):
            raise ValueError("Unsupported action: {}".format(action))
        self._action = action
        # We'll use the UDisks2 "ConnectionBus" property on the "Drive"
        # interface to do primary filtering. According to the documentation it
        # may have the following values: usb, sdio, ieee1394. The 'devices'
        # argument uses somewhat different strings. In particular we need to
        # map 'ieee1394' to 'firewire'
        #
        # See: http://udisks.freedesktop.org/docs/latest/gdbus-org.freedesktop.UDisks2.Drive.html#gdbus-property-org-freedesktop-UDisks2-Drive.ConnectionBus
        #
        # TODO: Report old unsupported possibilities that are still offered by
        # the command-line interface. We also need samples to understand how
        # UDisks2 behaves in practice on various devices.
        self._desired_connection_buses = [
            device if device != 'firewire' else 'ieee1394'
            for device in devices]
        # Store DBus bus object as we need to pass it to UDisks2 observer
        self._bus = system_bus
        # Store main loop object
        self._loop = loop
        # Setup UDisks2Observer class to track changes published by UDisks2
        self._udisks2_observer = UDisks2Observer()
        # Register a callback for either device insertion or removal, depending
        # on the required test. IMPORTANT: those callbacks will be processed
        # before the internal callbacks registered by UDisks2Model. This is
        # essential as it will allow us to react before the model is updated.
        if self._action == "insert":
            self._udisks2_observer.on_interfaces_added.connect(
                self._on_interfaces_added)
        elif self._action == "remove":
            self._udisks2_observer.on_interfaces_removed.connect(
                self._on_interfaces_removed)
        # Setup UDisks2Model to know what the current state is. This is needed
        # when remove events are reported as they don't carry enough state for
        # the program to work correctly. Since UDisks2Model only applies the
        # changes _after_ processing the signals from UDisks2Observer we can
        # reliably check all of the properties of the removed object / device.
        self._udisks2_model = UDisks2Model(self._udisks2_observer)
        # Assume the test passes, this is changed when timeout expires or when
        # an incorrect device gets inserted.
        self._error = False

    def check(self, timeout):
        """
        Run the configured test and return the result

        The result is False if the test has failed.  The timeout, when
        non-zero, will make the test fail after the specified seconds have
        elapsed without conclusive result.
        """
        # Setup a timeout if requested
        if timeout > 0:
            GObject.timeout_add_seconds(timeout, self._on_timeout_expired)
        # Connect the observer to the bus. This will start giving us events
        # (actually when the loop starts later below)
        self._udisks2_observer.connect_to_bus(self._bus)
        # Start the loop and wait. The loop will exit either when:
        # 1) A proper device has been detected (either insertion or removal)
        # 2) A timeout (optional) has expired
        self._loop.run()
        # Return the outcome of the test
        return self._error

    def _on_timeout_expired(self):
        """
        Internal function called when the timer expires.

        Basically it's just here to tell the user the test failed or that the
        user was unable to alter the device during the allowed time.
        """
        print("You have failed to perform the required manipulation in time")
        # Fail the test when the timeout was reached
        self._error = True
        # Stop the loop now
        self._loop.quit()

    def _on_interfaces_added(self, object_path, interfaces_and_properties):
        """
        Internal function called when UDisks2 notices new objects
        """
        for interface, properties in interfaces_and_properties.items():
            # Check all added interfaces, look for the "Drive" interface only
            if interface != self.UDISKS2_DRIVE_INTERFACE:
                continue
            # Stop the test after seeing a "Drive" interface
            self._loop.quit()
            # Whenever a drive is plugged in but not on the bus that we
            # expected signal an error and quit looking for more.
            connection_bus = (
                properties.get(self.UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS))
            if connection_bus not in self._desired_connection_buses:
                self._error = True
                print("You have inserted a device on bus {!r},"
                      " expected: {!r}".format(connection_bus,
                                               self._desired_connection_buses))
            else:
                print("Expected device {path} "
                      "inserted on the {bus} bus".format(
                          path=object_path, bus=connection_bus))
            # TODO: check for memory cards precisely
            # TODO: minimum speed unsupported in UDisks2,
            # needs separate USB3 checks

    def _on_interfaces_removed(self, object_path, interfaces):
        """
        Internal function called when UDisks2 notices removed objects
        """
        for interface in interfaces:
            # Check all added interfaces, look for the "Drive" interface only
            if interface != self.UDISKS2_DRIVE_INTERFACE:
                continue
            # Stop the test after seeing a "Drive" interface
            self._loop.quit()
            # Whenever a drive is removed but not on the bus that we
            # expected signal an error and quit looking for more.
            try:
                interfaces_and_properties = (
                    self._udisks2_model.managed_objects[object_path])
                properties = (
                    interfaces_and_properties[self.UDISKS2_DRIVE_INTERFACE])
                connection_bus = (
                    properties[self.UDISKS2_DRIVE_PROPERTY_CONNECTION_BUS])
            except KeyError:
                logging.error(
                    "Unable to locate connection bus used by %r", object_path)
                continue
            if connection_bus not in self._desired_connection_buses:
                self._error = True
                print("You have removed a device on bus {!r},"
                      " expected: {!r}".format(connection_bus,
                                               self._desired_connection_buses))
            else:
                print("Expected device {path} "
                      "removed from the {bus} bus".format(
                          path=object_path, bus=connection_bus))
            # TODO: check for memory cards precisely
            # TODO: minimum speed unsupported in UDisks2,
            # needs separate USB3 checks


def main():
    description = "Wait for the specified device to be inserted or removed."
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('action', choices=['insert', 'remove'])
    parser.add_argument('device', choices=['usb', 'sdio', 'firewire', 'scsi',
                                 'ata_serial_esata'], nargs="+")
    memorycard_help = ("Memory cards devices on bus other than sdio require "
                       "this parameter to identify them as such")
    parser.add_argument('--memorycard', action="store_true",
                        help=memorycard_help)
    parser.add_argument('--timeout', type=int, default=20)
    min_speed_help = ("Will only accept a device if its connection speed "
                      "attribute is higher than this value "
                      "(in bits/s)")
    parser.add_argument('--minimum_speed', '-m', help=min_speed_help,
                        type=int, default=0)
    parser.add_argument('--verbose', action='store_const', const=logging.INFO,
                        dest='logging_level', help="Enable verbose output")
    parser.add_argument('--debug', action='store_const', const=logging.DEBUG,
                        dest='logging_level', help="Enable debugging")
    parser.set_defaults(logging_level=logging.WARNING)
    args = parser.parse_args()

    # Configure logging as requested
    # XXX: This may be incorrect as logging.basicConfig() fails after any other
    # call to logging.log(). The proper solution is to setup a verbose logging
    # configuration and I didn't want to do it now.
    logging.basicConfig(
        level=args.logging_level,
        format='[%(asctime)s] %(levelname)s:%(name)s:%(message)s')

    # Connect to the system bus, we also get the event
    # loop as we need it to start listening for signals.
    system_bus, loop = connect_to_system_bus()

    # Check if system bus has the UDisks2 object
    if is_udisks2_supported(system_bus):
        # Construct the listener with all of the arguments provided on the
        # command line and the explicit system_bus, loop objects.
        logging.debug("Using UDisks2 interface")
        listener = UDisks2StorageDeviceListener(
            system_bus, loop,
            args.action, args.device, args.minimum_speed, args.memorycard)
    else:
        # Construct the listener with all of the arguments provided on the
        # command line and the explicit system_bus, loop objects.
        logging.debug("Using UDisks1 interface")
        listener = UDisks1StorageDeviceListener(
            system_bus, loop,
            args.action, args.device, args.minimum_speed, args.memorycard)
    # Run the actual listener and wait till it either times out of discovers
    # the appropriate media changes
    try:
        return listener.check(args.timeout)
    except KeyboardInterrupt:
        return 1

if __name__ == "__main__":
    sys.exit(main())
