#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# graphics_stress_test
#
# This file is part of Checkbox.
#
# Copyright 2012 Canonical Ltd.
#
# Authors: Alberto Milone <alberto.milone@canonical.com>
#
# Checkbox is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Checkbox is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Checkbox.  If not, see <http://www.gnu.org/licenses/>.

import logging
import os
import re
import sys
import time

from argparse import ArgumentParser
from subprocess import call, Popen, PIPE


class VtWrapper(object):
    """docstring for VtWrapper"""
    def __init__(self):
        self.x_vt = self._get_x_vt()

    def _get_x_vt(self):
        '''Get the vt where X lives'''
        vt = 0
        proc = Popen(['ps', 'aux'], stdout=PIPE, universal_newlines=True)
        proc_output = proc.communicate()[0].split('\n')
        proc_line = re.compile('.*tty(\d+).+/usr/bin/X.*')
        for line in proc_output:
            match = proc_line.match(line)
            if match:
                vt = match.group(1).strip().lower()
        return int(vt)

    def set_vt(self, vt):
        retcode = call(['chvt', '%d' % vt])
        return retcode

class SuspendWrapper(object):
    def __init__(self):
        pass

    def can_we_sleep(self, mode):
        '''
        Test to see if S3 state is available to us.  /proc/acpi/* is old
        and will be deprecated, using /sys/power to maintine usefulness for
        future kernels.

        '''
        states_fh = open('/sys/power/state', 'r')
        try:
            states = states_fh.read().split()
        finally:
            states_fh.close()

        if mode in states:
            return True
        else:
            return False

    def get_current_time(self):
        cur_time = 0
        time_fh = open('/sys/class/rtc/rtc0/since_epoch', 'r')
        try:
            cur_time = int(time_fh.read())
        finally:
            time_fh.close()
        return cur_time

    def set_wake_time(self, time):
        '''
        Get the current epoch time from /sys/class/rtc/rtc0/since_epoch
        then add time and write our new wake_alarm time to
        /sys/class/rtc/rtc0/wakealarm.

        The math could probably be done better but this method avoids having to
        worry about whether or not we're using UTC or local time for both the
        hardware and system clocks.

        '''
        cur_time = self.get_current_time()
        logging.debug('Current epoch time: %s' % cur_time)

        wakealarm_fh = open('/sys/class/rtc/rtc0/wakealarm', 'w')

        try:
            wakealarm_fh.write('0\n')
            wakealarm_fh.flush()

            wakealarm_fh.write('+%s\n' % time)
            wakealarm_fh.flush()
        finally:
            wakealarm_fh.close()

        logging.debug('Wake alarm in %s seconds' % time)

    def do_suspend(self, mode):
        '''
        Suspend the system and hope it wakes up.
        Previously tried writing new state to /sys/power/state but that
        seems to put the system into an uncrecoverable S3 state.  So far,
        pm-suspend seems to be the most reliable way to go.

        '''
        if mode == 'mem':
            status = call('/usr/sbin/pm-suspend')
        elif mode == 'disk':
            status = call('/usr/sbin/pm-hibernate')
        else:
            logging.debug('Unknown sleep state passed')
            status == 1

        return status


def main():
    # Make sure that we have root privileges
    if os.geteuid() != 0:
        print('Error: please run this program as root',
              file=sys.stderr)
        exit(1)

    usage = 'Usage: %prog [OPTIONS]'
    parser = ArgumentParser(usage)
    parser.add_argument('-i', '--iterations',
                        type=int,
                        default=10,
                        help='The number of times to run the test. \
                              Default is 10')
    parser.add_argument('-o', '--output',
                        default='',
                        help='The path to the log which will be dumped. \
                              Default is stdout')
    parser.add_argument('-s', '--scripts_path',
                        default='scripts',
                        help='The path to the log which will be dumped. \
                              Default is scripts/')
    args = parser.parse_args()

    loglevel = logging.DEBUG
    if not args.output:
        logging.basicConfig(format='%(message)s',
                            level=loglevel)
    else:
        logging.basicConfig(filename=args.output,
                            format='%(message)s',
                            level=loglevel)

    status = 0

    # Switch between the tty where X lives and tty10
    vt_wrap = VtWrapper()
    target_vt = 10
    if vt_wrap.x_vt != target_vt:
        logging.info('== Vt switch test ==')
        for it in range(args.iterations):
            logging.info('Iteration %d...', it)
            retcode = vt_wrap.set_vt(target_vt)
            if retcode != 0:
                logging.error('Error: switching to tty%d failed with code %d '
                      'on iteration %d' % (target_vt, retcode, it))
                status = 1
            else:
                logging.info('Switching to tty%d: passed' % (target_vt))
            time.sleep(2)
            retcode = vt_wrap.set_vt(vt_wrap.x_vt)
            if retcode != 0:
                logging.error('Error: switching to tty%d failed with code %d '
                      'on iteration %d' % (vt_wrap.x_vt, retcode, it))
            else:
                logging.info('Switching to tty%d: passed' % (vt_wrap.x_vt))
                status = 1
    else:
        logging.error('Error: please run X on a tty other than 10')

    # Call sleep 10 times
    logging.info('== Sleep test ==')
    sleep_test = SuspendWrapper()
    sleep_mode = 'mem'
    # See if we can sleep
    if sleep_test.can_we_sleep(sleep_mode):
        for it in range(args.iterations):
            # Run the test
            logging.info('Iteration %d...', it + 1)
            # Set wake time
            sleep_test.set_wake_time(10)
            # Suspend to RAM
            if sleep_test.do_suspend(sleep_mode) == 0:
                logging.info('Passed')
            else:
                logging.error('Failed')
    else:
        # Skip the test
        logging.info('Skipped (the system does not seem to support S3')

    # Rotate the screen 10 times
    # The app already rotates the screen 5 times
    logging.info('== Rotation test ==')
    for it in range(args.iterations):
        # rotation_status = call(['scripts/rotation_test'])
        # if sleep_status != 0:
        #     logging.error('Error: rotating the screen on iteration %d'
        #           % (it))
        #     status = 1
        process = Popen([os.path.join(args.scripts_path,
                         'rotation_test')], stdout=PIPE,
                         stderr=PIPE, universal_newlines=True)
        output, error = process.communicate()

        logging.info('Iteration %d...', it + 1)
        if output:
            logging.debug(output)
        if error:
            logging.debug(error)
        if process.returncode != 0:
            logging.error('Failed')
            status = 1
        else:
            logging.info('Passed')

    # Call rendercheck 10 times
    logging.info('== Rendercheck test ==')
    if args.output:
        render_status = call([os.path.join(args.scripts_path,
                                           'rendercheck_test'),
                              '-d', '-i', '%d' % args.iterations,
                              '-o', args.output])
    else:
        render_status = call([os.path.join(args.scripts_path,
                                           'rendercheck_test'),
                              '-d', '-i', '%d' % args.iterations])
    if render_status != 0:
        status = render_status

    return status

if __name__ == '__main__':
    exit(main())
