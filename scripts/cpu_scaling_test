#!/usr/bin/python

import decimal
import os
import re
import string
import sys
import time

from optparse import OptionParser
from subprocess import check_call, CalledProcessError

class CPUScalingTest():
    def __init__(self, options):
        self.options = options
        self.speedUpTolerance = 10.0 # percent
        self.retryLimit = 5
        self.retryTolerance = 5.0 # percent
        self.sysCPUDirectory = "/sys/devices/system/cpu"
        self.cpufreqDirectory = "%s/cpu%s/cpufreq" % (self.sysCPUDirectory, "0")
        self.idaFlag = "ida"
        self.idaSpeedupFactor = 8.0 # percent

    def getCPUFreqDirectories(self):        
        if not os.path.exists(self.sysCPUDirectory):
            print "Error: no file %s" % self.sysCPUDirectory
            return None
        # look for cpu subdirectories
        pattern = re.compile("cpu(?P<cpuNumber>[0-9]+)")  
        self.cpufreqDirectories = list()          
        for subdirectory in os.listdir(self.sysCPUDirectory):
            match = pattern.search(subdirectory)
            if match and match.group("cpuNumber"):
                cpufreqDirectory = "%s/%s/cpufreq" % (self.sysCPUDirectory,
                                                      subdirectory)
                if not os.path.exists(cpufreqDirectory):
                    print "Error: cpu %s has no cpufreq directory %s" \
                        % (match.group("cpuNumber"), cpufreqDirectory)
                    return None
                # otherwise
                self.cpufreqDirectories.append(cpufreqDirectory)
        if len(self.cpufreqDirectories) is 0:
            return None
        # otherwise
        return self.cpufreqDirectories

    def checkParameters(self, file):
        current = None
        for cpufreqDirectory in self.cpufreqDirectories:
            parameters = self.getParameters(cpufreqDirectory, file)
            if not parameters:
                print "Error: could not determine cpu parameters from %s/%s" \
                    % (cpufreqDirectory, file)
                return None
            if not current:
                current = parameters
            elif not current == parameters:
                return None      
        return current

    def getParameters(self, cpufreqDirectory, file):
        file = open("%s/%s" % (cpufreqDirectory, file))
        while 1:
            line = file.readline()
            if not line:
                break
            if len(line.strip()) > 0:
                return line.strip().split()
        return None

    def getParameterList(self, parameter):
        values = list()
        for cpufreqDirectory in self.cpufreqDirectories:
            parameterFile = open("%s/%s" % (cpufreqDirectory, parameter))
            line = parameterFile.readline()
            if not line:
                print "Error: failed to get %s for %s" % (parameter, cpufreqDirectory)
                return None
            values.append(line.strip())
        return values
        
    def getCPUFlags(self):
        self.cpuFlags = None
        try:
            cpuinfo_file = open('/proc/cpuinfo', 'r')
            cpuinfo = cpuinfo_file.read().split("\n")
            cpuinfo_file.close()

            for line in cpuinfo:
                if line.startswith('flags'):
                    pre, post = line.split(':')
                    self.cpuFlags = post.strip().split()
                    break
        except:
            print "Warning: could not read CPU flags"

    def getCPUCapabilities(self):
        print ""
        print "System Capabilites:"
        print "-------------------------------------------------"

        # Do the CPUs support scaling?        
        if not self.getCPUFreqDirectories():
            return False
        if len (self.cpufreqDirectories) > 1:
            print "System has %u cpus"% len(self.cpufreqDirectories)
        
        # Ensure all CPUs support the same frequencies
        freqFileName = "scaling_available_frequencies"
        self.frequencies = self.checkParameters(freqFileName)
        if not self.frequencies:
            return False
        
        print ""
        print "Supported CPU Frequencies: "
        for freq in self.frequencies:
            f = string.atoi(freq)/1000
            print "    %u MHz" % f
        
        # Check governors to verify all CPUs support the same control methods
        governorFileName = "scaling_available_governors"
        self.governors = self.checkParameters(governorFileName)
        if not self.governors:
            return False
        
        print ""
        print "Supported Governors: "
        comma = False
        for governor in self.governors:
            print "    %s" % governor
        
        self.originalGovernors = self.getParameterList("scaling_governor")
        if self.originalGovernors:
            print ""
            print "Current governors:"
            i = 0
            for g in self.originalGovernors:
                print "    cpu%u: %s" % (i, g)
                i += 1
        else:
            print "Error: could not determine current governor settings"
            return False
        
        self.getCPUFlags()
        
        return False

    def setParameter(self, switch, setFile, readFile, value):
        # Try the command for all CPUs
        result = True
        try:
            command = check_call(["cpufreq-selector", "-%s" % switch,
                                  "%s" % value])
        except CalledProcessError, exception:
            print "Note: command failed: %s" % exception.returncode
            result = True
        
        if not result:
            print "Trying alternate method."
            try:
                command = check_call(["echo", "\"%s\"" % value, ">", 
                                      "%s/%s" % (self.cpufreqDirectory,  setFile)])
            except CalledProcessError, exception:
                print "Error: command failed:"
                print exception
                return False
    
        # verify it has changed
        parameterFile = open("%s/%s" % (self.cpufreqDirectory, readFile))
        line = parameterFile.readline()
        if not line or line.strip() != value:
            print "Error: could not verify that %s/%s was set to %s" % (self.cpufreqDirectory, readFile, value)
            if line:
                print "Actual Value: %s" % line
            else:
                print "parameter file was empty"           
            return False
        
        return True

    def getParameter(self, parameter):
        value = None
        parameterFilePath = "%s/%s" % (self.cpufreqDirectory, parameter)
        try:
            parameterFile = open(parameterFilePath)
            line = parameterFile.readline()
            if not line:
                print "Error: failed to get %s for %s" % (parameter, cpufreqDirectory)
                return None
            value = line.strip()         
            return value
        except IOError, exception:
            print "Error: could not open %s" % parameterFilePath
            print exception
            
        return None
    
    def setFrequency(self, frequency):
        return self.setParameter("f", "scaling_setspeed", "scaling_cur_freq", frequency)

    def setGovernor(self, governor):
        return self.setParameter("g", "scaling_governor", "scaling_governor", governor)

    def pi(self):
        decimal.getcontext().prec = 500
        s = decimal.Decimal(1)
        h = decimal.Decimal(3).sqrt()/2
        n = 6
        for i in range(170):
            A = n*h*s/2  # A ... area of polygon
            s2 = ((1-h)**2+s**2/4)
            s = s2.sqrt()
            h = (1-s2/4).sqrt()
            n = 2*n
        # print i,":",A
        return True

    def runLoadTest(self):
        print "Running CPU load test..."
        try:
            check_call(["taskset", "-pc", "0", "%s" % os.getpid()])
        except CalledProcessError, exception:
            print "Error: could not set task affinity"
            print exception
            return None
        
        runTime = None
        tries = 0
        while tries < self.retryLimit:
            sys.stdout.flush()
            (start_utime, start_stime, start_cutime, start_cstime, start_elapsed_time) = os.times()
            self.pi()
            (stop_utime, stop_stime, stop_cutime, stop_cstime, stop_elapsed_time) = os.times()
            if not runTime:
                runTime = stop_elapsed_time - start_elapsed_time
            else:
                thisTime = stop_elapsed_time - start_elapsed_time
                if (abs(thisTime-runTime)/runTime)*100 < self.retryTolerance:
                    return runTime
                else:
                    runTime = thisTime
            tries += 1
        
        print "Error: could not repeat load test times within %.1f%%" % self.retryTolerance
        return None    

    def runUserSpaceTests(self):
        print ""
        print "Userspace Governor Test:"
        print "-------------------------------------------------"
        self.differenceSpeedUp = None
        self.minimumFrequencyTestTime = None
        self.maximumFrequencyTestTime = None
        success = True
        governor = "userspace"
        if governor not in self.governors:
            print "Note: %s governor not supported" % governor
        else:
            
            # Set the governor to "userspace" and verify
            print "Setting governor to %s" % governor
            if not self.setGovernor(governor):
                success = False
            
            # Set the the CPU speed to it's lowest value
            frequency = self.frequencies[-1]
            print "Setting CPU frequency to %u MHz" % (string.atoi(frequency)/1000)    
            if not self.setFrequency(frequency):
                success = False

            # Verify the speed is set to the lowest value
            minimumFrequency = self.getParameter("scaling_min_freq")
            currentFrequency = self.getParameter("scaling_cur_freq")
            if not minimumFrequency or not currentFrequency or (minimumFrequency != currentFrequency):
                print "Error: Could not verify that cpu frequency is set to the minimum value of %s" % minimumFrequency
                success = False
            
            # Run Load Test
            self.minimumFrequencyTestTime = self.runLoadTest()
            if not self.minimumFrequencyTestTime:
                success = False
            print "Minimum frequency load test time: %.2f" % self.minimumFrequencyTestTime 
            
            # Set the CPU speed to it's highest value as above.
            frequency = self.frequencies[0]
            print "Setting CPU frequency to %u MHz" % (string.atoi(frequency)/1000)
            if not self.setFrequency(frequency):
                success = False
            
            maximumFrequency = self.getParameter("scaling_max_freq")
            currentFrequency = self.getParameter("scaling_cur_freq")
            if not maximumFrequency or not currentFrequency or (maximumFrequency != currentFrequency):
                print "Error: Could not verify that cpu frequency is set to the maximum value of %s" % maximumFrequency
                success = False
          
            # Repeat workload test
            self.maximumFrequencyTestTime = self.runLoadTest()
            if not self.maximumFrequencyTestTime:
                success = False
            print "Maximum frequency load test time: %.2f" % self.maximumFrequencyTestTime
            
            # Verify MHz increase is comparable to time % decrease
            predictedSpeedup = string.atof(maximumFrequency)/string.atof(minimumFrequency)
            
            # If "ida" turbo thing, increase the expectation by 8%
            if self.cpuFlags and self.idaFlag in self.cpuFlags:
                print "Note: found %s flag, increasing expected speedup by %.1f%%" % (self.idaFlag, self.idaSpeedupFactor)
                predictedSpeedup = predictedSpeedup*(1.0/(1.0-(self.idaSpeedupFactor/100.0)))
                
            measuredSpeedup = self.minimumFrequencyTestTime/self.maximumFrequencyTestTime
            print ""
            print "CPU Frequency Speed Up: %.2f" % predictedSpeedup
            print "Measured Speed Up: %.2f" % measuredSpeedup
            self.differenceSpeedUp =  (abs(measuredSpeedup-predictedSpeedup)/predictedSpeedup)*100
            print "Percentage Difference %.1f%%" % self.differenceSpeedUp
            if self.differenceSpeedUp > self.speedUpTolerance:
                print "Error: measured speedup vs expected speedup is %.1f%% and is not within %.1f%% margin. " % (self.differenceSpeedUp, self.speedUpTolerance)
                success = False
               
        return success

    def verifyMinimumFrequency(self):
        waitTime = 5
        sys.stdout.write("Waiting %d seconds..." % waitTime)
        sys.stdout.flush()
        time.sleep(waitTime)
        sys.stdout.write(" done.\n")
        minimumFrequency = self.getParameter("scaling_min_freq")
        currentFrequency = self.getParameter("scaling_cur_freq")
        if not minimumFrequency or not currentFrequency or (minimumFrequency != currentFrequency):
            return False
        
        # otherwise
        return True

    def runOnDemandTests(self):
        print ""
        print "On Demand Governor Test:"
        print "-------------------------------------------------"
        self.differenceOnDemandVsMaximum = None
        self.onDemandTestTime = None
        governor = "ondemand"
        success = True
        if governor not in self.governors:
            print "Note: %s governor not supported" % governor
        else:
            # Set the governor to "ondemand"
            print "Setting governor to %s" % governor
            if not self.setGovernor(governor):
                success = False
            
            # Wait a fixed period of time, then verify current speed is the slowest in as before
            if not self.verifyMinimumFrequency():
                print "Error: Could not verify that cpu frequency has settled to the minimum value"
                success = False
            
            # Repeat workload test
            self.onDemandTestTime = self.runLoadTest()
            if not self.onDemandTestTime:
                success = False
            print "On Demand load test time: %.2f" % self.onDemandTestTime
            
            # Compare the timing to the max results from earlier, again time should be within self.speedUpTolerance
            self.differenceOnDemandVsMaximum = (abs(self.onDemandTestTime-self.maximumFrequencyTestTime)/self.maximumFrequencyTestTime)*100
            print "Percentage Difference vs. maximum frequency: %.1f%%" % self.differenceOnDemandVsMaximum
            if self.differenceOnDemandVsMaximum > self.speedUpTolerance:
                print "Error: on demand performance vs maximum of %.1f%% is not within %.1f%% margin" % (self.differenceOnDemandVsMaximum, self.speedUpTolerance)
                success = False

            # Verify the current speed has returned to the lowest speed again
            if not self.verifyMinimumFrequency():
                print "Error: Could not verify that cpu frequency has settled to the minimum value"
                success = False
               
        return success

    def runPerformanceTests(self):
        print ""
        print "Performance Governor Test:"
        print "-------------------------------------------------"
        self.differencePerformanceVsMaximum = None
        governor = "performance"
        success = True
        if governor not in self.governors:
            print "Note: %s governor not supported" % governor
        else:
            # Set the governor to "performance"
            print "Setting governor to %s" % governor
            if not self.setGovernor(governor):
                success = False
        
            # Verify the current speed is the same as scaling_max_freq
            maximumFrequency = self.getParameter("scaling_max_freq")
            currentFrequency = self.getParameter("scaling_cur_freq")
            if not maximumFrequency or not currentFrequency or (maximumFrequency != currentFrequency):
                print "Error: Current cpu frequency of %s is not set to the maximum value of %s" % (currentFrequency, maximumFrequency)
                success = False
            
            # Repeat work load test
            self.performanceTestTime = self.runLoadTest()
            if not self.performanceTestTime:
                success = False
            print "Performance load test time: %.2f" % self.performanceTestTime
        
            # Compare the timing to the max results
            self.differencePerformanceVsMaximum = (abs(self.performanceTestTime-self.maximumFrequencyTestTime)/self.maximumFrequencyTestTime)*100
            print "Percentage Difference vs. maximum frequency: %.1f%%" % self.differencePerformanceVsMaximum
            if self.differencePerformanceVsMaximum > self.speedUpTolerance:
                print "Error: performance setting vs maximum of %.1f%% is not within %.1f%% margin" % (self.differencePerformanceVsMaximum, self.speedUpTolerance)
                success = False
            
        return success

    def runConservativeTests(self):
        print ""
        print "Conservative Governor Test:"
        print "-------------------------------------------------"
        self.differenceConservativeVsMinimum = None
        governor = "conservative"
        success = True
        if governor not in self.governors:
            print "Note: %s governor not supported" % governor
        else:
            # Set the governor to "conservative"
            print "Setting governor to %s" % governor
            if not self.setGovernor(governor):
                success = False
        
            # Verify the current speed is the same as scaling_min_freq
            minimumFrequency = self.getParameter("scaling_min_freq")
            currentFrequency = self.getParameter("scaling_cur_freq")
            if not minimumFrequency or not currentFrequency or (minimumFrequency != currentFrequency):
                print "Error: Current cpu frequency of %s is not set to the minimum value of %s" % (currentFrequency, minimumFrequency)
                success = False
            
            # Repeat work load test
            self.conservativeTestTime = self.runLoadTest()
            if not self.conservativeTestTime:
                success = False
            print "Conservative load test time: %.2f" % self.conservativeTestTime
        
            # Compare the timing to the max results
            self.differenceConservativeVsMaximum = (abs(self.conservativeTestTime-self.minimumFrequencyTestTime)/self.minimumFrequencyTestTime)*100
            print "Percentage Difference vs. minimum frequency: %.1f%%" % self.differenceConservativeVsMinimum
            if self.differenceConservativeVsMinimum > self.speedUpTolerance:
                print "Error: performance setting vs minimum of %.1f%% is not within %.1f%% margin" % (self.differenceConservativeVsMinimum, self.speedUpTolerance)
                success = False
            
        return success

    def restoreGovernors(self):
        print "Restoring original governor to %s" % (self.originalGovernors[0])
        self.setGovernor(self.originalGovernors[0])

def parse_options(args):
    """
    Parse command line options.
    """
    parser = OptionParser()
    parser.add_option("-q", "--quiet", action="store_true",
                      help="Suppress output.")
    parser.add_option("-c", "--capabilities", action="store_true",
                      help="Only output CPU capabilities.")
    return parser.parse_args(args)[0]


if __name__ == "__main__":
    returnValue = 0
    options = parse_options(sys.argv)

    if options.quiet:
        sys.stdout = open(os.devnull, 'a')
        sys.stderr = open(os.devnull, 'a')

    test = CPUScalingTest(options)
    returnValue = test.getCPUCapabilities()
    if not options.capabilities:
        returnValue = test.runUserSpaceTests()
        returnValue = test.runOnDemandTests()
        returnValue = test.runPerformanceTests()
        returnValue = test.runConservativeTests()
        test.restoreGovernors()
    sys.exit(returnValue)
