#!/usr/bin/python
import sys
import time
import re
from tempfile import NamedTemporaryFile
from subprocess import check_call as call
from subprocess import CalledProcessError, Popen, PIPE, STDOUT
import argparse
from glob import glob
import gobject


class CameraTest:
    """
    A simple class that displays a test image via GStreamer.
    """
    def __init__(self, args):
        self.args = args
        self._mainloop = gobject.MainLoop()
        self._width = 640
        self._height = 480

    def detect(self):
        """
        Display information regarding webcam hardware
        """
        process = Popen(["xawtv", "-hwscan"], stdout=PIPE, stderr=STDOUT)
        (output, _) = process.communicate()

        output = "\n".join([line for line in output.splitlines()[2:]
                            if line])
        print output

        if re.search('^/dev/video\d+:\s+OK', output, re.M):
            return 0
        else:
            return 1

    def led(self):
        """
        Activate camera (switch on led), but don't display any output
        """
        pipespec = ("v4l2src device=%(device)s "
                    "! video/x-raw-yuv "
                    "! ffmpegcolorspace "
                    "! testsink"
                    % {'device': self.args.device})
        self._pipeline = gst.parse_launch(pipespec)
        self._pipeline.set_state(gst.STATE_PLAYING)
        time.sleep(10)
        self._pipeline.set_state(gst.STATE_READY)

    def display(self):
        """
        Displays the preview window
        """
        pipespec = ("v4l2src device=%(device)s "
                    "! video/x-raw-yuv,width=%(width)d,height=%(height)d "
                    "! ffmpegcolorspace "
                    "! autovideosink"
                    % {'device': self.args.device,
                       'width': self._width,
                       'height': self._height})
        self._pipeline = gst.parse_launch(pipespec)
        self._pipeline.set_state(gst.STATE_PLAYING)
        time.sleep(10)
        self._pipeline.set_state(gst.STATE_READY)

    def still(self):
        """
        Captures an image to a file
        """
        if self.args.filename:
            self._still_helper(self.args.filename)
        else:
            with NamedTemporaryFile(prefix='camera_test_', suffix='.jpg') as f:
                self._still_helper(f.name)

    def _still_helper(self, filename):
        """
        Captures an image to a given filename
        """
        try:
            call(["fswebcam", "-S 3", "--no-banner",
                  "-d", self.args.device,
                  "-r", "%dx%d"
                  % (self._width, self._height), filename])
        except (CalledProcessError, OSError):
            pipespec = \
                    ("v4l2src device=%(device)s "
                     "! video/x-raw-yuv,width=%(width)d,height=%(height)d "
                     "! ffmpegcolorspace "
                     "! jpegenc "
                     "! filesink location=%(filename)s"
                     % {'device': self.args.device,
                         'width': self._width,
                        'height': self._height,
                        'filename': filename})
            self._pipeline = gst.parse_launch(pipespec)
            self._pipeline.set_state(gst.STATE_PLAYING)
            time.sleep(3)
            self._pipeline.set_state(gst.STATE_READY)

        if not self.args.quiet:
            call(["eog", filename])


def parse_arguments(argv):
    """
    Parse command line arguments
    """
    parser = argparse.ArgumentParser(description="Run a camera-related test")
    subparsers = parser.add_subparsers(dest='test',
                                       title='test',
                                       description='Available camera tests')

    def add_device_parameter(parser):
        group = parser.add_mutually_exclusive_group()
        group.add_argument("-d", "--device", default="/dev/video0",
                           help="Device for the webcam to use")
        group.add_argument("--highest-device", action="store_true",
                           help=("Use the /dev/videoN "
                                 "where N is the highest value available"))
        group.add_argument("--lowest-device", action="store_true",
                           help=("Use the /dev/videoN "
                                 "where N is the lowest value available"))

    subparsers.add_parser('detect')
    led_parser = subparsers.add_parser('led')
    add_device_parameter(led_parser)
    display_parser = subparsers.add_parser('display')
    add_device_parameter(display_parser)
    still_parser = subparsers.add_parser('still')
    add_device_parameter(still_parser)
    still_parser.add_argument("-f", "--filename",
                              help="Filename to store the picture")
    still_parser.add_argument("-q", "--quiet", action="store_true",
                              help=("Don't display picture, "
                                    "just write the picture to a file"))
    args = parser.parse_args(argv)

    def get_video_devices():
        devices = sorted(glob('/dev/video[0-9]'),
                         key=lambda d: re.search(r'\d', d).group(0))
        assert len(devices) > 0, "No video devices found"
        return devices

    if hasattr(args, 'highest_device') and args.highest_device:
        args.device = get_video_devices()[-1]
    elif hasattr(args, 'lowest_device') and args.lowest_device:
        args.device = get_video_devices()[0]
    return args


if __name__ == "__main__":
    args = parse_arguments(sys.argv[1:])

    # Import gst only for the test cases that will need it
    if args.test in ['display', 'still', 'led']:
        import pygst
        pygst.require("0.10")
        import gst

    camera = CameraTest(args)
    sys.exit(getattr(camera, args.test)())
