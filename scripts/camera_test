#!/usr/bin/env python3

import sys
import time
import re
import fcntl
import ctypes
from tempfile import NamedTemporaryFile
from subprocess import check_call as call
from subprocess import CalledProcessError, Popen, PIPE, STDOUT
import argparse
from glob import glob
from gi.repository import GObject


_IOC_NRBITS = 8
_IOC_TYPEBITS = 8
_IOC_SIZEBITS = 14

_IOC_NRSHIFT = 0
_IOC_TYPESHIFT = _IOC_NRSHIFT + _IOC_NRBITS
_IOC_SIZESHIFT = _IOC_TYPESHIFT + _IOC_TYPEBITS
_IOC_DIRSHIFT = _IOC_SIZESHIFT + _IOC_SIZEBITS

_IOC_READ = 2


def _IOC(dir_, type_, nr, size):
    return (
        ctypes.c_int32(dir_ << _IOC_DIRSHIFT).value |
        ctypes.c_int32(ord(type_) << _IOC_TYPESHIFT).value |
        ctypes.c_int32(nr << _IOC_NRSHIFT).value |
        ctypes.c_int32(size << _IOC_SIZESHIFT).value)


def _IOR(type_, nr, size):
    return _IOC(_IOC_READ, type_, nr, ctypes.sizeof(size))


class v4l2_capability(ctypes.Structure):
    """
    Driver capabilities
    """
    _fields_ = [
        ('driver', ctypes.c_char * 16),
        ('card', ctypes.c_char * 32),
        ('bus_info', ctypes.c_char * 32),
        ('version', ctypes.c_uint32),
        ('capabilities', ctypes.c_uint32),
        ('reserved', ctypes.c_uint32 * 4),
    ]


# Values for 'capabilities' field
V4L2_CAP_VIDEO_CAPTURE = 0x00000001
V4L2_CAP_VIDEO_OVERLAY = 0x00000004
V4L2_CAP_READWRITE = 0x01000000
V4L2_CAP_STREAMING = 0x04000000

# ioctl code for video devices
VIDIOC_QUERYCAP = _IOR('V', 0, v4l2_capability)

class CameraTest:
    """
    A simple class that displays a test image via GStreamer.
    """
    def __init__(self, args):
        self.args = args
        self._mainloop = GObject.MainLoop()
        self._width = 640
        self._height = 480

    def detect(self):
        """
        Display information regarding webcam hardware
        """
        status = 1
        for i in range(10):
            cp = v4l2_capability()
            device = '/dev/video%d' %i
            try:
                with open(device, 'r') as vd:
                    fcntl.ioctl(vd, VIDIOC_QUERYCAP, cp)
            except IOError:
                continue
            status = 0
            print("%s: OK" %device)
            print("    name  : %s" %cp.card.decode('UTF-8'))
            print("    driver: %s" %cp.driver.decode('UTF-8'))
            print("    flags : 0x%x [" %cp.capabilities,
            ' CAPTURE' if cp.capabilities & V4L2_CAP_VIDEO_CAPTURE else '',
            ' OVERLAY' if cp.capabilities & V4L2_CAP_VIDEO_OVERLAY else '',
            ' READWRITE' if cp.capabilities & V4L2_CAP_READWRITE else '',
            ' STREAMING' if cp.capabilities & V4L2_CAP_STREAMING else '',
            ' ]', sep="")
        return status

    def led(self):
        """
        Activate camera (switch on led), but don't display any output
        """
        pipespec = ("v4l2src device=%(device)s "
                    "! video/x-raw-yuv "
                    "! ffmpegcolorspace "
                    "! testsink"
                    % {'device': self.args.device})
        self._pipeline = Gst.parse_launch(pipespec)
        self._pipeline.set_state(Gst.State.PLAYING)
        time.sleep(10)
        self._pipeline.set_state(Gst.State.NULL)

    def display(self):
        """
        Displays the preview window
        """
        pipespec = ("v4l2src device=%(device)s "
                    "! video/x-raw-yuv,width=%(width)d,height=%(height)d "
                    "! ffmpegcolorspace "
                    "! autovideosink"
                    % {'device': self.args.device,
                       'width': self._width,
                       'height': self._height})
        self._pipeline = Gst.parse_launch(pipespec)
        self._pipeline.set_state(Gst.State.PLAYING)
        time.sleep(10)
        self._pipeline.set_state(Gst.State.NULL)

    def still(self):
        """
        Captures an image to a file
        """
        if self.args.filename:
            self._still_helper(self.args.filename)
        else:
            with NamedTemporaryFile(prefix='camera_test_', suffix='.jpg') as f:
                self._still_helper(f.name)

    def _still_helper(self, filename):
        """
        Captures an image to a given filename
        """
        try:
            call(["fswebcam", "-S 3", "--no-banner",
                  "-d", self.args.device,
                  "-r", "%dx%d"
                  % (self._width, self._height), filename])
        except (CalledProcessError, OSError):
            pipespec = \
                    ("v4l2src device=%(device)s "
                     "! video/x-raw-yuv,width=%(width)d,height=%(height)d "
                     "! ffmpegcolorspace "
                     "! jpegenc "
                     "! filesink location=%(filename)s"
                     % {'device': self.args.device,
                         'width': self._width,
                        'height': self._height,
                        'filename': filename})
            self._pipeline = Gst.parse_launch(pipespec)
            self._pipeline.set_state(Gst.State.PLAYING)
            time.sleep(3)
            self._pipeline.set_state(Gst.State.NULL)

        if not self.args.quiet:
            call(["eog", filename])


def parse_arguments(argv):
    """
    Parse command line arguments
    """
    parser = argparse.ArgumentParser(description="Run a camera-related test")
    subparsers = parser.add_subparsers(dest='test',
                                       title='test',
                                       description='Available camera tests')

    def add_device_parameter(parser):
        group = parser.add_mutually_exclusive_group()
        group.add_argument("-d", "--device", default="/dev/video0",
                           help="Device for the webcam to use")
        group.add_argument("--highest-device", action="store_true",
                           help=("Use the /dev/videoN "
                                 "where N is the highest value available"))
        group.add_argument("--lowest-device", action="store_true",
                           help=("Use the /dev/videoN "
                                 "where N is the lowest value available"))

    subparsers.add_parser('detect')
    led_parser = subparsers.add_parser('led')
    add_device_parameter(led_parser)
    display_parser = subparsers.add_parser('display')
    add_device_parameter(display_parser)
    still_parser = subparsers.add_parser('still')
    add_device_parameter(still_parser)
    still_parser.add_argument("-f", "--filename",
                              help="Filename to store the picture")
    still_parser.add_argument("-q", "--quiet", action="store_true",
                              help=("Don't display picture, "
                                    "just write the picture to a file"))
    args = parser.parse_args(argv)

    def get_video_devices():
        devices = sorted(glob('/dev/video[0-9]'),
                         key=lambda d: re.search(r'\d', d).group(0))
        assert len(devices) > 0, "No video devices found"
        return devices

    if hasattr(args, 'highest_device') and args.highest_device:
        args.device = get_video_devices()[-1]
    elif hasattr(args, 'lowest_device') and args.lowest_device:
        args.device = get_video_devices()[0]
    return args


if __name__ == "__main__":
    args = parse_arguments(sys.argv[1:])

    # Import Gst only for the test cases that will need it
    if args.test in ['display', 'still', 'led']:
        from gi.repository import Gst
        Gst.init(None)

    camera = CameraTest(args)
    sys.exit(getattr(camera, args.test)())
