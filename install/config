#!/usr/bin/python
#
# This program is meant to be called by the debian installer in order to
# create configuration files for the hwtest package and derived packages
# based on the preseed values. The arguments are almost the same as used
# by debconf. The only difference is that the first argument passed to
# the script must be the name of the package. Also, the following options
# are supported:
#
# -v, --variable  Optional variables to preseed in the configuration file.

import os
import re
import sys
from ConfigParser import ConfigParser
from optparse import OptionParser

from debconf import Debconf, DebconfCommunicator, DebconfError, MEDIUM


DEFAULTSECT = "DEFAULT"


class Config(ConfigParser):

    def write(self, fp):
        """Write an .ini-format representation of the configuration state."""
        if self._defaults:
            fp.write("[%s]\n" % DEFAULTSECT)
            defaults = dict(self._defaults)

            # Write includes first
            if 'includes' in defaults:
                key = 'includes'
                value = defaults.pop(key)
                value = str(value).replace('\n', '\n\t')
                fp.write("%s = %s\n" % (key, value))

            for (key, value) in defaults.items():
                value = str(value).replace('\n', '\n\t')
                fp.write("%s = %s\n" % (key, value))

            fp.write("\n")

        for section in self._sections:
            fp.write("[%s]\n" % section)
            for (key, value) in self._sections[section].items():
                if key != "__name__":
                    fp.write("%s = %s\n" %
                             (key, str(value).replace('\n', '\n\t')))

            fp.write("\n")


class Install(object):
    """Install module for generating hwtest configuration files.

    The hwtest module and derivatives use a configuration file format
    compatible with ConfigParser. The values for the keys defined in
    this file can be preseeded during the installation of the package by
    using this module during the config phase of the package installation
    process.
    """
    separator = "/"
    configs_base = "/usr/share/%(base_name)s/configs/%(name)s.ini"
    examples_base = "/usr/share/%(base_name)s/examples/%(name)s.ini"

    def __init__(self, name, config_path=None, example_path=None, variables=[]):
        self.name = name
        self.base_name = re.sub(r"-[^-]+$", "", name)
        self._variables = variables
        self._configs_path = config_path or self.configs_base \
            % {"name": name, "base_name": self.base_name}
        self._examples_path = example_path or self.examples_base \
            % {"name": name, "base_name": self.base_name}

        # Create config directory
        dirname = os.path.dirname(self._configs_path)
        if not os.path.exists(dirname):
            os.mkdir(dirname)

        self._config = Config()
        if os.environ.get("DEBIAN_HAS_FRONTEND"):
            if os.environ.get("DEBCONF_REDIR"):
                write = os.fdopen(3, "w")
            else:
                write = sys.stdout
            self._debconf = Debconf(write=write)
        else:
            self._debconf = DebconfCommunicator(self.name)

    def write(self, output):
        """
        Write phase of the config process which takes an output file
        as argument.
        """
        for path in [self._examples_path, self._configs_path]:
            if path and os.path.isfile(path):
                self._config.read(path)

        # Set configuration variables
        for variable in self._variables:
            section, name = variable.rsplit(self.separator, 1)
            value = self._debconf.get(variable)
            self._config.set(section, name, value)

        # Write config file
        descriptor = open(output, "w")
        self._config.write(descriptor)
        descriptor.close()

    def configure(self, priority=MEDIUM):
        """
        Configure phase of the config process.
        """
        path = self._configs_path
        if path and os.path.isfile(path):
            self._config.read(path)

        # Set debconf variables
        for variable in self._variables:
            section, name = variable.rsplit(self.separator, 1)
            if self._config.has_option(section, name):
                self._debconf.set(variable, self._config.get(section, name))

        # Ask questions and set new values, if needed.
        step = 0
        while step < len(self._variables):
            if step < 0:
                raise Exception, "Stepped too far back."
            variable = self._variables[step]
            try:
                self._debconf.input(priority, variable)
            except DebconfError, error:
                if error.args[0] != 30:
                    raise
                # Question preivously answered and skipped.
                step += 1
            else:
                try:
                    self._debconf.go()
                except DebconfError, error:
                    if error.args[0] != 30:
                        raise
                    # User requested to go back.
                    step -= 1
                else:
                    step += 1


def main(args):
    """
    Main routine for running this script. The arguments are:

    package_name   Name of the package to configure.
    command        Name of the command to run as defined by debconf.
    optional       Optional arguments specific to the given command.
    """
    parser = OptionParser()
    parser.add_option("-v", "--variables",
      default=[],
      action="append",
      help="List of preseed variables.")
    args = sys.argv[1:]
    (options, args) = parser.parse_args(args)

    if len(args) < 2:
        return 1

    package = args[0]
    variables = options.variables
    install = Install(package, variables=variables)

    command = args[1]
    if command == "write":
        output = args[2]
        install.write(output)
    elif command == "configure":
        install.configure()

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
