#!/usr/bin/python
#
# This program is meant to be called by the debian installer in order to
# create configuration files for the hwtest package and derived packages
# based on the preseed values. The arguments are the same as used by
# debconf when calling the .config script in the package. The stdin
# provides defines the package to be configured. For example:
# 
# [DEFAULT]
# package = my_package
# variables =
#   preseed_var1
#   preseed_var2

import os
import re
import sys
import ConfigParser
from optparse import OptionParser

from debconf import Debconf, DebconfCommunicator, DebconfError, MEDIUM


class Install(object):

    separator = "/"
    config_base = "/etc/hwtest.d/%(name)s.conf"
    example_base = "/usr/share/doc/%(name)s/examples/%(name)s.conf"

    def __init__(self, name, config_path=None, example_path=None, variables=[]):
        self.name = name
        self._variables = variables
        self._config_path = config_path or self.config_base % {"name": name}
        self._example_path = example_path or self.example_base % {"name": name}

        self._config = ConfigParser.ConfigParser()
        if os.environ.get("DEBIAN_HAS_FRONTEND"):
            if os.environ.get("DEBCONF_REDIR"):
                write = os.fdopen(3, "w")
            else:
                write = sys.stdout
            self._debconf = Debconf(write=write)
        else:
            self._debconf = DebconfCommunicator(self.name)

    def set_example(self, path):
        self._example_path = path

    def set_config(self, path):
        self._config_path = path

    def set_variables(self, variables):
        self._variables = variables

    def write(self, output):
        for path in [self._example_path, self._config_path]:
            if path and os.path.isfile(path):
                self._config.read(path)

        # Set configuration variables
        for variable in self._variables:
            section, name = variable.rsplit(self.separator, 1)
            value = self._debconf.get(variable)
            self._config.set(section, name, value)

        # Write config
        f = open(output, "w")
        self._config.write(f)
        f.close()

    def configure(self, priority=MEDIUM):
        path = self._config_path
        if path and os.path.isfile(path):
            self._config.read(path)

        # Set debconf variables
        for variable in self._variables:
            section, name = variable.rsplit(self.separator, 1)
            if self._config.has_option(section, name):
                self._debconf.set(variable, self._config.get(section, name))

        # Ask questions and set new values, if needed.
        step = 0
        while step < len(self._variables):
            if step < 0:
                raise Exception, "Stepped too far back."
            variable = self._variables[step]
            try:
                self._debconf.input(priority, variable)
            except DebconfError, e:
                if e.args[0] != 30:
                    raise
                # Question preivously answered and skipped.
                step += 1
            else:
                try:
                    self._debconf.go()
                except DebconfError, e:
                    if e.args[0] != 30:
                        raise
                    # User requested to go back.
                    step -= 1
                else:
                    step += 1


def main(args):
    parser = OptionParser()
    parser.add_option("-v", "--variables",
      default=[],
      action="append",
      help="List of preseed variables.")
    args = sys.argv[1:]
    (options, args) = parser.parse_args(args)

    if len(args) < 2:
        return 1

    package = args[0]
    variables = options.variables
    install = Install(package, variables=variables)

    command = args[1]
    if command == "write":
        output = args[2]
        install.write(output)
    elif command == "configure":
        install.configure()

    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
